{
  "$schema": "https://www.krakend.io/schema/krakend.json",
  "version": 3,
  "name": "KrakenD Enterprise API Gateway",
  "port": 8080,
  "host": [
    "http://localhost:8080"
  ],
  "timeout": "3000ms",
  "cache_ttl": "300s",
  "debug_endpoint": true,
  "plugin": {
    "pattern": ".so",
    "folder": "/opt/krakend/plugins/"
  },
  "endpoints": [
    {
      "@comment": "Feature: Aggregation and basic transformation",
      "endpoint": "/git/{user}",
      "backend": [
        {
          "host": [
            "https://api.github.com"
          ],
          "url_pattern": "/users/{user}",
          "allow": [
            "avatar_url",
            "name",
            "company",
            "blog",
            "location",
            "mail",
            "hireable",
            "followers",
            "public_repos",
            "public_gists"
          ],
          "mapping": {
            "blog": "website"
          },
          "group": "user"
        },
        {
          "host": [
            "https://api.github.com"
          ],
          "url_pattern": "/users/{user}/repos",
          "mapping": {
            "collection": "repos"
          },
          "is_collection": true
        }
      ],
      "extra_config": {
        "documentation/postman": {
          "name": "Aggregate GitHub User & Repos",
          "description": "Demonstrates API composition by aggregating user profile and repositories from GitHub API in parallel",
          "folder": "/API Composition"
        },
        "documentation/openapi": {
          "summary": "Merges two calls from github and serves under a single endpoint",
          "description": "This endpoint fetches in parallel the user information and the repository information from Githuib and returns it together. Non interesting fields are removed.",
          "tags": [
            "API Composition"
          ]
        }
      }
    },
    {
      "@comment": "EE only feature: Advanced transformation with query language",
      "endpoint": "/cryptos/{currency}",
      "output_encoding": "json-collection",
      "backend": [
        {
          "host": [
            "https://api.coingecko.com"
          ],
          "url_pattern": "/api/v3/coins/markets?vs_currency={currency}&order=market_cap_desc&per_page=100&page=1&sparkline=false",
          "encoding": "safejson",
          "extra_config": {
            "modifier/martian": {
              "header.Blacklist": {
                "scope": [
                  "request"
                ],
                "names": [
                  "X-Forwarded-Host"
                ]
              }
            }
          }
        }
      ],
      "extra_config": {
        "modifier/jmespath": {
          "@comment": "Get first 5 crypto by market capitalization, then reverse sort them by name, finally filter and rename some fields",
          "expr": "reverse(sort_by(collection[:5], &name))[*].{name: name, token: symbol,price: current_price, price_change: price_change_percentage_24h, market_cap: market_cap}"
        },
        "documentation/postman": {
          "name": "Transform Crypto Data with JMESPath",
          "description": "Advanced response transformation using JMESPath query language to filter and sort cryptocurrency market data",
          "folder": "/API Composition"
        },
        "documentation/openapi": {
          "summary": "Get TOP 5 crypto capitalization & price data for a given currency",
          "description": "This endpoint fetches some crypto capitalization data from Coingecko for a given currency.",
          "tags": [
            "API Composition"
          ]
        }
      }
    },
    {
      "@comment": "Feature: Regular expression manipulation",
      "endpoint": "/user/creditcard",
      "backend": [
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/user/1.json",
          "allow": [
            "credit_card"
          ],
          "extra_config": {
            "modifier/response-body": {
              "modifiers": [
                {
                  "regexp": {
                    "field": "credit_card.number",
                    "@comment": "Ridiculous card masking. Show last 4 digits and remove the rest. Credit card number is nested.",
                    "find": "^.*(\\d{4})",
                    "replace": "XXXX-${1}"
                  }
                }
              ]
            }
          }
        }
      ],
      "extra_config": {
        "documentation/postman": {
          "name": "Mask Credit Card Number",
          "description": "Demonstrates data masking using regex to hide sensitive credit card information (shows only last 4 digits)",
          "folder": "/API Composition"
        },
        "documentation/openapi": {
          "summary": "Mask the credit card number",
          "description": "This endpoint fetches the user information and masks the credit card number",
          "tags": [
            "API Composition"
          ]
        }
      }
    },
    {
      "@comment": "Feature: Security policy engine for requests, responses and claim checking",
      "endpoint": "/track-user",
      "@test_with": "curl -iG -H'Cookie: GDPR=yes' 'http://localhost:8080/track-user'",
      "input_headers": [
        "Cookie"
      ],
      "backend": [
        {
          "host": [
            "http://localhost:8080"
          ],
          "url_pattern": "/__debug/cookie"
        }
      ],
      "extra_config": {
        "security/policies": {
          "req": {
            "policies": [
              "getCookie('GDPR') == 'yes'"
            ],
            "error": {
              "body": "User did not accept the cookie and tracking is not allowed",
              "status": 403
            }
          }
        },
        "documentation/postman": {
          "name": "GDPR Cookie Policy Enforcement",
          "description": "Enforces security policy requiring GDPR cookie acceptance before allowing tracking requests",
          "folder": "/Authentication & Security"
        },
        "documentation/openapi": {
          "summary": "Tracks user activity when the GDPR cookie is accepted",
          "description": "Example on how to abort a request based on a security policy. If the user does not have the GDPR cookie set to 'yes', the request will be aborted.",
          "tags": [
            "Authentication & Security"
          ]
        }
      }
    },
    {
      "@comment": "Feature: Two types of rate limiting on aggregated content",
      "endpoint": "/shop",
      "backend": [
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/shop/campaigns.json",
          "allow": [
            "campaigns"
          ]
        },
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/shop/products.json",
          "allow": [
            "products"
          ],
          "extra_config": {
            "qos/ratelimit/proxy": {
              "max_rate": 1,
              "capacity": 1
            }
          }
        }
      ],
      "extra_config": {
        "qos/ratelimit/router": {
          "max_rate": 2
        },
        "documentation/postman": {
          "name": "Multi-Level Rate Limiting",
          "description": "Demonstrates router-level and backend-level rate limiting on aggregated shop data (campaigns + products)",
          "folder": "/API Composition"
        },
        "documentation/openapi": {
          "summary": "Aggregates campaigns and products from the shop using different ratelimits",
          "description": "This endpoint fetches the campaigns and products from the shop. The campaigns are fetched without ratelimit, but the products are fetched with a rate limit of 1 request per second. The endpoint itself has a rate limit of 2 requests per second.",
          "tags": [
            "API Composition",
            "Performance & QoS"
          ]
        }
      }
    },
    {
      "@comment": "Feature: Backend cache",
      "endpoint": "/market/cached",
      "extra_config": {
        "documentation/postman": {
          "name": "Backend HTTP Cache",
          "description": "Demonstrates backend response caching using Cache-Control headers to reduce external API calls",
          "folder": "/Performance & QoS"
        },
        "documentation/openapi": {
          "summary": "Local cache for the crypto market information",
          "description": "This endpoint caches the responses from the Coingecko API for the time returned in the Cache-Control header.",
          "tags": [
            "Performance & QoS"
          ]
        }
      },
      "backend": [
        {
          "host": [
            "https://api.coingecko.com"
          ],
          "url_pattern": "/api/v3/coins/markets?vs_currency=eur&ids=bitcoin%2Cethereum&order=market_cap_desc&per_page=100&page=1&sparkline=false",
          "encoding": "safejson",
          "mapping": {
            "collection": "coins"
          },
          "extra_config": {
            "qos/http-cache": {
              "shared": true
            },
            "modifier/martian": {
              "header.Blacklist": {
                "scope": [
                  "request"
                ],
                "names": [
                  "X-Forwarded-Host"
                ]
              }
            }
          }
        }
      ]
    },
    {
      "@comment": "Feature: GraphQL to REST",
      "endpoint": "/starwars_films/{movie_id}",
      "extra_config": {
        "documentation/postman": {
          "name": "GraphQL to REST - Star Wars Films",
          "description": "Converts GraphQL API to REST endpoint for fetching Star Wars movie information",
          "folder": "/Protocol Conversion"
        },
        "documentation/openapi": {
          "summary": "Connect to a GraphQL server and fetch the film information",
          "description": "This endpoint connects to a GraphQL server and offers the interaction as a regular REST endpoint.",
          "tags": [
            "Protocol Conversion"
          ]
        }
      },
      "backend": [
        {
          "host": [
            "https://swapi-graphql.netlify.app/"
          ],
          "url_pattern": "/.netlify/functions/index",
          "target": "data.film",
          "extra_config": {
            "backend/graphql": {
              "type": "query",
              "query": "query Query ($movie_id: ID!) {\nfilm (filmID: $movie_id) {\nid\nepisodeID\ntitle\ndirector\nreleaseDate\nspeciesConnection {\nspecies {\nname\nclassification\nhomeworld {\nname\n}\n}\n}\n}\n}",
              "variables": {
                "movie_id": "{movie_id}"
              }
            }
          }
        }
      ]
    },
    {
      "@comment": "Feature: Concurrent calls - Initial example with no concurrent calls enabled (normal)",
      "endpoint": "/market/simple",
      "backend": [
        {
          "host": [
            "https://api.coingecko.com"
          ],
          "url_pattern": "/api/v3/coins/markets?vs_currency=eur&ids=bitcoin%2Cethereum&order=market_cap_desc&per_page=100&page=1&sparkline=false",
          "encoding": "safejson",
          "mapping": {
            "collection": "coins"
          },
          "extra_config": {
            "modifier/martian": {
              "header.Blacklist": {
                "scope": [
                  "request"
                ],
                "names": [
                  "X-Forwarded-Host"
                ]
              }
            }
          }
        }
      ],
      "extra_config": {
        "documentation/postman": {
          "name": "Simple Request (No Concurrency)",
          "description": "Baseline example of a single non-concurrent API call to external service",
          "folder": "/Performance & QoS"
        },
        "documentation/openapi": {
          "summary": "Simple fetch of external data without concurrent calls enabled",
          "description": "This endpoint fetches crypto market information from Coingecko using a single non-concurrent call.",
          "tags": [
            "Performance & QoS"
          ]
        }
      }
    },
    {
      "@comment": "Feature: Concurrent calls - Example with concurrent calls enabled (more speed, less errors)",
      "endpoint": "/market/concurrent",
      "concurrent_calls": 3,
      "backend": [
        {
          "host": [
            "https://api.coingecko.com"
          ],
          "url_pattern": "/api/v3/coins/markets?vs_currency=eur&ids=bitcoin%2Cethereum&order=market_cap_desc&per_page=100&page=1&sparkline=false",
          "encoding": "safejson",
          "mapping": {
            "collection": "coins"
          },
          "extra_config": {
            "modifier/martian": {
              "header.Blacklist": {
                "scope": [
                  "request"
                ],
                "names": [
                  "X-Forwarded-Host"
                ]
              }
            }
          }
        }
      ],
      "extra_config": {
        "documentation/postman": {
          "name": "Concurrent Requests (3x)",
          "description": "Demonstrates concurrent calls feature - makes 3 parallel requests and returns the fastest successful response",
          "folder": "/Performance & QoS"
        },
        "documentation/openapi": {
          "summary": "Get crypto market information with 3 concurrent calls",
          "description": "This endpoint fetches crypto market information from Coingecko using 3 concurrent calls. Returns the fastest successful response and discards the rest",
          "tags": [
            "Performance & QoS"
          ]
        }
      }
    },
    {
      "@comment": "Feature: Sequential calls, using values from 1st call response into 2nd call request",
      "endpoint": "/sequential",
      "extra_config": {
        "proxy": {
          "sequential": true
        },
        "documentation/postman": {
          "name": "Sequential API Calls",
          "description": "Demonstrates sequential requests where second call uses data from first response (hotel -> destination lookup)",
          "folder": "/API Composition"
        },
        "documentation/openapi": {
          "summary": "Chains two sequential API calls where the second depends on the first",
          "description": "This endpoint demonstrates sequential processing by first fetching a hotel, then using its destination_id to fetch destination details. The second call cannot start until the first completes.",
          "tags": [
            "API Composition"
          ]
        }
      },
      "backend": [
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/hotels/1.json",
          "allow": [
            "destination_id"
          ]
        },
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/destinations/{resp0_destination_id}.json"
        }
      ]
    },
    {
      "@comment": "Feature: Expose a GET REST endpoint from POST to SOAP service",
      "endpoint": "/capital-of/{country}",
      "extra_config": {
        "documentation/postman": {
          "name": "SOAP to REST - Country Capital",
          "description": "Converts SOAP XML service to REST JSON endpoint for retrieving country capital information",
          "folder": "/Protocol Conversion"
        },
        "documentation/openapi": {
          "summary": "Interact with a SOAP server as a regular REST API",
          "description": "This endpoint interacts with a SOAP server but offers a pure REST interface to the consumer",
          "tags": [
            "Protocol Conversion"
          ]
        }
      },
      "backend": [
        {
          "host": [
            "http://webservices.oorsprong.org"
          ],
          "url_pattern": "/websamples.countryinfo/CountryInfoService.wso",
          "encoding": "xml",
          "method": "POST",
          "target": "Envelope.Body.CapitalCityResponse",
          "mapping": {
            "CapitalCityResult": "capital"
          },
          "deny": [
            "-m"
          ],
          "extra_config": {
            "backend/soap": {
              "@comment": "The XML template with variables is in the following path:",
              "path": "./extended/templates/soap_request_capital_city.tmpl.xml"
            }
          }
        }
      ]
    },
    {
      "@comment": "EE only feature: Wildcard to our fake API, open",
      "endpoint": "/fake-api/*",
      "backend": [
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/"
        }
      ],
      "extra_config": {
        "documentation/postman": {
          "name": "Wildcard Routing (Open)",
          "description": "Public wildcard endpoint forwarding all paths under /fake-api/* to backend service",
          "folder": "/Routing & Wildcards"
        },
        "documentation/openapi": {
          "summary": "Calls to internal service with wildcard",
          "description": "This endpoint will send all requests to a designed backend including everything after the /fake-api path",
          "tags": [
            "Routing & Wildcards"
          ]
        }
      }
    },
    {
      "@comment": "EE only feature: Wildcard to our fake API, protected with Basic Auth",
      "endpoint": "/fake-api-auth/*",
      "@test_with": "curl -iG 'http://admin:admin@localhost:8080/fake-api-auth/articles.json'",
      "output_encoding": "no-op",
      "backend": [
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/"
        }
      ],
      "extra_config": {
        "@comment": "The simple inclusion of the Auth Basic component enables it for this endpoint",
        "auth/basic": {},
        "documentation/postman": {
          "name": "Wildcard Routing with Basic Auth",
          "description": "Protected wildcard endpoint requiring Basic Authentication (credentials: admin/admin)",
          "folder": "/Routing & Wildcards"
        },
        "documentation/openapi": {
          "summary": "Calls to internal service with wildcard, adding auth",
          "description": "This endpoint will send all requests to a designed backend including everything after the /fake-api-auth path, adding Basic Authentication",
          "tags": [
            "Routing & Wildcards",
            "Authentication & Security"
          ]
        }
      }
    },
    {
      "@comment": "EE only feature: Wildcard with geofencing - Allow visits only from Spain",
      "endpoint": "/fake-api-geofence/*",
      "input_headers": [
        "X-Geoip"
      ],
      "backend": [
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/"
        }
      ],
      "extra_config": {
        "validation/cel": [
          {
            "check_expr": "req_headers['X-Geoip'][0].matches('\"IsoCode\":\"ES\"')"
          }
        ],
        "documentation/postman": {
          "name": "Wildcard Routing with Geofencing",
          "description": "Geo-restricted wildcard endpoint allowing access only from Spain using CEL validation",
          "folder": "/Routing & Wildcards"
        },
        "documentation/openapi": {
          "summary": "Calls to internal service with wildcard, using geofencing",
          "description": "This endpoint will send all requests to a designed backend including everything after the /fake-api-geofence path, adding geofencing (allowing calls only from Spain)",
          "tags": [
            "Routing & Wildcards"
          ]
        }
      }
    },
    {
      "@comment": "EE only feature: Dynamic routing based on headers (token claim and cookie also available)",
      "endpoint": "/dynamic/header",
      "extra_config": {
        "documentation/postman": {
          "name": "Dynamic Routing by Header",
          "description": "Routes to different backend paths based on X-Route header value (test with: curl -H 'X-Route: hello')",
          "folder": "/Routing & Wildcards"
        },
        "documentation/openapi": {
          "summary": "Route to the backend using the content of the 'X-Route' header",
          "description": "This endpoint demonstrates dynamic routing by using the X-Route header value to determine the backend path. Test with: curl -iG -H 'X-Route: hello' 'http://localhost:8080/dynamic/header'",
          "tags": [
            "Routing & Wildcards"
          ]
        }
      },
      "backend": [
        {
          "@comment": "We will route to the backend using the content of the 'X-Route' header",
          "@test_with": "curl -iG -H 'X-Route: hello' 'http://localhost:8080/dynamic/header'",
          "url_pattern": "/__debug/{input_headers.x-route}"
        }
      ]
    },
    {
      "@comment": "EE only feature: Dynamic routing based on query strings",
      "endpoint": "/dynamic/qs",
      "extra_config": {
        "documentation/postman": {
          "name": "Dynamic Routing by Query String",
          "description": "Routes to different backend paths based on 'route' query parameter value",
          "folder": "/Routing & Wildcards"
        },
        "documentation/openapi": {
          "summary": "Route to the backend using the 'route' query string parameter",
          "description": "This endpoint demonstrates dynamic routing by using the route query parameter value to determine the backend path. Test with: curl -iG 'http://localhost:8080/dynamic/qs?route=hello'",
          "tags": [
            "Routing & Wildcards"
          ]
        }
      },
      "backend": [
        {
          "url_pattern": "/__debug/{input_query_strings.route}"
        }
      ]
    },
    {
      "@comment": "Feature: A public endpoint that requires no authentication",
      "cache_ttl": "1s",
      "endpoint": "/public",
      "extra_config": {
        "documentation/postman": {
          "name": "Public Endpoint (No Auth)",
          "description": "Baseline public endpoint requiring no authentication - useful for testing",
          "folder": "/Authentication & Security"
        },
        "documentation/openapi": {
          "summary": "Public endpoint",
          "description": "This endpoint is public and requires no authentication",
          "tags": [
            "Authentication & Security"
          ]
        }
      },
      "backend": [
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/hotels/1.json"
        }
      ]
    },
    {
      "@comment": "Feature: Authentication and authorization",
      "endpoint": "/auth/*",
      "extra_config": {
        "documentation/postman": {
          "name": "Auth Web UI",
          "description": "Web interface demonstrating JWT authentication/authorization flow with Keycloak",
          "folder": "/Authentication & Security"
        },
        "documentation/openapi": {
          "summary": "Full example for JWT based authentication / authorization with Keycloack",
          "description": "This endpoint offers a web interface to present auth/authz flow with Keycloack.",
          "tags": [
            "Authentication & Security"
          ]
        }
      },
      "output_encoding": "no-op",
      "backend": [
        {
          "url_pattern": "/",
          "host": [
            "http://web:3000/"
          ],
          "encoding": "no-op"
        }
      ]
    },
    {
      "@comment": "Feature: Authorization based on JWT (using Keycloak)",
      "endpoint": "/private/moderate",
      "cache_ttl": "1s",
      "backend": [
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/user/1.json"
        }
      ],
      "extra_config": {
        "auth/validator": {
          "alg": "RS256",
          "audience": [
            "playground"
          ],
          "roles_key_is_nested": true,
          "roles_key": "realm_access.roles",
          "roles": [
            "moderator"
          ],
          "jwk_url": "http://keycloak:8080/realms/krakend/protocol/openid-connect/certs",
          "disable_jwk_security": true
        },
        "documentation/postman": {
          "name": "JWT Auth with Keycloak (Moderator Role)",
          "description": "Protected endpoint requiring JWT token from Keycloak with 'moderator' role",
          "folder": "/Authentication & Security"
        },
        "documentation/openapi": {
          "summary": "Some information behind JWT authentication protection (Keycloak)",
          "description": "This endpoint uses JWT authentication with Keycloak",
          "tags": [
            "Authentication & Security"
          ]
        }
      }
    },
    {
      "@comment": "Feature: Authorization based on JWT (using KrakenD JOSE signer)",
      "endpoint": "/private/custom",
      "backend": [
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/user/1.json"
        }
      ],
      "extra_config": {
        "auth/validator": {
          "alg": "HS256",
          "audience": [
            "http://api.example.com"
          ],
          "roles_key": "roles",
          "issuer": "https://krakend.io",
          "roles": [
            "role_a",
            "role_c"
          ],
          "jwk_local_path": "/opt/krakend/jwk-symmetric.json",
          "disable_jwk_security": true
        },
        "documentation/postman": {
          "name": "JWT Auth with KrakenD Signer",
          "description": "Protected endpoint using KrakenD's internal JWT signing with role-based authorization",
          "folder": "/Authentication & Security"
        },
        "documentation/openapi": {
          "summary": "Sign a token cryptographically (KrakenD JOSE signer)",
          "description": "This endpoint uses the KrakenD JOSE signer to sign plain tokens coming from the backend and helpiong you to adopt cryptography easily",
          "tags": [
            "Authentication & Security"
          ]
        }
      }
    },
    {
      "@comment": "Feature: JWT signing, as described at https://www.krakend.io/docs/authorization/jwt-signing/",
      "endpoint": "/token",
      "backend": [
        {
          "host": [
            "http://fake_api"
          ],
          "url_pattern": "/token.json"
        }
      ],
      "extra_config": {
        "documentation/postman": {
          "name": "JWT Token Signing",
          "description": "Signs backend tokens (access_token, refresh_token) using KrakenD JWT signer",
          "folder": "/Authentication & Security"
        },
        "documentation/openapi": {
          "description": "This endpoint uses JWT signing",
          "summary": "Some information behind JWT signing",
          "tags": [
            "Authentication & Security"
          ]
        },
        "auth/signer": {
          "alg": "HS256",
          "kid": "sim2",
          "keys_to_sign": [
            "access_token",
            "refresh_token"
          ],
          "jwk_local_path": "/opt/krakend/jwk-symmetric.json",
          "disable_jwk_security": true
        }
      }
    },
    {
      "@comment": "EE only feature: Authorization based on API Keys",
      "endpoint": "/api-key",
      "backend": [
        {
          "url_pattern": "/__debug/admin",
          "host": [
            "http://localhost:8080"
          ]
        }
      ],
      "extra_config": {
        "auth/api-keys": {
          "roles": [
            "admin"
          ]
        },
        "documentation/postman": {
          "name": "API Key Authentication",
          "description": "Protected endpoint requiring valid API key with 'admin' role (Enterprise-only feature)",
          "folder": "/Authentication & Security"
        },
        "documentation/openapi": {
          "summary": "Some information behind API-Keys authentication protection",
          "description": "This endpoint uses API-Key authentication",
          "tags": [
            "Authentication & Security"
          ]
        }
      }
    },
    {
      "@comment": "Feature: Only POST method allowed",
      "endpoint": "/post",
      "method": "POST",
      "backend": [
        {
          "url_pattern": "/__debug/post"
        }
      ],
      "extra_config": {
        "documentation/postman": {
          "name": "POST-Only Endpoint",
          "description": "Demonstrates HTTP method restriction - only POST requests allowed",
          "folder": "/Routing & Wildcards"
        },
        "documentation/openapi": {
          "summary": "Only POST method allowed",
          "description": "This endpoint only allows POST requests",
          "tags": [
            "Routing & Wildcards"
          ]
        }
      }
    },
    {
      "@comment": "Feature: Mocked response",
      "endpoint": "/mocked-response",
      "method": "GET",
      "output_encoding": "json",
      "backend": [
        {
          "host": [
            "http://unexistent_backend"
          ],
          "url_pattern": "/"
        }
      ],
      "extra_config": {
        "proxy": {
          "static": {
            "data": {
              "an_integer": 123,
              "an_array": [
                "arr1",
                "arr2"
              ],
              "an_object": {
                "obj": "obj1"
              }
            },
            "strategy": "always"
          }
        },
        "documentation/postman": {
          "name": "Mocked Static Response",
          "description": "Returns static mocked data without calling the backend - useful for testing and development",
          "folder": "/API Composition"
        },
        "documentation/openapi": {
          "summary": "Mocked response",
          "description": "This endpoint returns a mocked response when the backend is not available",
          "tags": [
            "API Composition"
          ]
        }
      }
    },
    {
      "@comment": "EE only feature: GRPC",
      "endpoint": "/travel",
      "extra_config": {
        "documentation/postman": {
          "name": "gRPC Aggregation - Travel Search",
          "description": "Aggregates flights, trains, and hotels from gRPC services into unified REST response",
          "folder": "/Protocol Conversion"
        },
        "documentation/openapi": {
          "summary": "Find flights, trains and hotels",
          "description": "This endpoint fetches flights, trains and hotels information from different backends",
          "tags": [
            "Protocol Conversion",
            "API Composition"
          ]
        }
      },
      "input_query_strings": [
        "lat",
        "lon"
      ],
      "backend": [
        {
          "host": [
            "grpc_flights:4242"
          ],
          "group": "flights",
          "url_pattern": "/flight_finder.Flights/FindFlight",
          "extra_config": {
            "backend/grpc": {
              "input_mapping": {
                "lat": "where.latitude",
                "lon": "where.longitude"
              }
            }
          }
        },
        {
          "host": [
            "grpc_trains:4243"
          ],
          "group": "trains",
          "url_pattern": "/train_finder.Trains/FindTrains",
          "extra_config": {
            "backend/grpc": {
              "input_mapping": {
                "lat": "origin.position.latitude",
                "lon": "origin.position.longitude"
              },
              "response_naming_convention": "camelCase",
              "output_enum_as_string": true,
              "output_timestamp_as_string": true,
              "output_duration_as_string": true,
              "client_tls": {
                "allow_insecure_connections": true
              }
            }
          }
        },
        {
          "group": "hotels",
          "url_pattern": "/hotels/1.json"
        },
        {
          "host": [
            "grpc_trains:4243"
          ],
          "group": "trains_classes",
          "url_pattern": "/train_finder.Trains/GetTrainClasses",
          "extra_config": {
            "backend/grpc": {
              "response_naming_convention": "camelCase",
              "output_remove_unset_values": true,
              "client_tls": {
                "allow_insecure_connections": true
              }
            }
          }
        }
      ]
    },
    {
      "@comment": "EE only feature: GRPC Payload in Body",
      "endpoint": "/travel_book_flight/{id_flight}/{main_passenger}",
      "extra_config": {
        "documentation/postman": {
          "name": "gRPC with Body - Book Flight",
          "description": "Books a flight via gRPC backend using request body and path parameters",
          "folder": "/Protocol Conversion"
        },
        "documentation/openapi": {
          "summary": "Book a flight",
          "description": "This endpoint books a flight using a GRPC backend",
          "tags": [
            "Protocol Conversion"
          ]
        }
      },
      "method": "POST",
      "backend": [
        {
          "host": [
            "grpc_flights:4242"
          ],
          "group": "flights",
          "url_pattern": "/flight_finder.Flights/BookFlight",
          "extra_config": {
            "backend/grpc": {
              "input_mapping": {
                "Id_flight": "flight_id",
                "Main_passenger": "main_passenger.full_name"
              },
              "use_request_body": true
            }
          }
        }
      ]
    },
    {
      "@comment": "EE only feature: WebSockets (chat example)",
      "endpoint": "/chat/ws/{room}",
      "input_query_strings": [
        "*"
      ],
      "input_headers": [
        "*"
      ],
      "backend": [
        {
          "url_pattern": "/ws/{room}",
          "disable_host_sanitize": true,
          "host": [
            "ws://chat:8888"
          ]
        }
      ],
      "extra_config": {
        "websocket": {
          "input_headers": [
            "Cookie",
            "Authorization"
          ],
          "connect_event": true,
          "disconnect_event": true,
          "read_buffer_size": 4096,
          "write_buffer_size": 4096,
          "message_buffer_size": 4096,
          "max_message_size": 3200000,
          "write_wait": "10s",
          "pong_wait": "60s",
          "ping_period": "54s",
          "max_retries": 0,
          "backoff_strategy": "exponential"
        },
        "documentation/postman": {
          "name": "WebSocket Chat - Connection",
          "description": "WebSocket endpoint for real-time chat room communication with configurable room parameter",
          "folder": "/Real-time Communication"
        },
        "documentation/openapi": {
          "summary": "Chat room using WebSockets",
          "description": "This endpoint connects to a chat server using WebSockets",
          "tags": [
            "Real-time Communication"
          ]
        }
      }
    },
    {
      "@comment": "EE only feature: WebSockets (chat example web interface)",
      "endpoint": "/chat",
      "extra_config": {
        "documentation/postman": {
          "name": "WebSocket Chat - Web UI",
          "description": "Web interface for testing WebSocket chat functionality in the browser",
          "folder": "/Real-time Communication"
        },
        "documentation/openapi": {
          "summary": "Chat room User Interface",
          "description": "This endpoint offers a web interface to present a chat room",
          "tags": [
            "Real-time Communication"
          ]
        }
      },
      "output_encoding": "no-op",
      "backend": [
        {
          "url_pattern": "/",
          "host": [
            "http://chat:8888"
          ],
          "encoding": "no-op"
        }
      ]
    },
    {
      "@comment": "EE only feature: Web Server - Static content",
      "endpoint": "/demo/*",
      "output_encoding": "no-op",
      "backend": [
        {
          "url_pattern": "/",
          "extra_config": {
            "backend/static-filesystem": {
              "directory_listing": false,
              "path": "./demo/"
            }
          },
          "host": [
            "http://localhost:8080"
          ],
          "encoding": "no-op"
        }
      ],
      "extra_config": {
        "documentation/postman": {
          "name": "Static File Server - Demo Site",
          "description": "Serves static content from demo folder including HTML, CSS, JS, and images",
          "folder": "/Utilities"
        },
        "documentation/openapi": {
          "summary": "Serve static content",
          "description": "This endpoint serves static content from the demo folder",
          "tags": [
            "Utilities"
          ]
        }
      }
    },
    {
      "@comment": "EE only feature: MCP Server - Entrypoint for Model Context Protocol",
      "endpoint": "/mcp",
      "method": "POST",
      "timeout": "15s",
      "backend": [
        {
          "url_pattern": "/ignore",
          "host": [
            "http://ignore"
          ]
        }
      ],
      "extra_config": {
        "ai/mcp": {
          "server_name": "country-data-aggregator"
        },
        "documentation/postman": {
          "name": "MCP Server - Country Data Tools",
          "description": "Model Context Protocol (MCP) server for AI/LLM integration - aggregates country data from REST + GraphQL APIs",
          "folder": "/AI Integration"
        },
        "documentation/openapi": {
          "summary": "MCP Server entrypoint for country data tools",
          "description": "Model Context Protocol (MCP) server exposing country information aggregation tools. Accepts MCP protocol requests and routes them to appropriate handlers that aggregate REST and GraphQL APIs.",
          "tags": [
            "AI Integration"
          ]
        }
      }
    }
  ],
  "sequential_start": true,
  "async_agent": [
    {
      "name": "async-agent-demo",
      "backend": [
        {
          "host": [
            "http://127.0.0.1:8080"
          ],
          "url_pattern": "/__debug/async-agent-demo",
          "method": "POST"
        }
      ],
      "consumer": {
        "topic": "*.bar",
        "workers": 20
      },
      "connection": {
        "max_retries": 10,
        "backoff_strategy": "exponential-jitter"
      },
      "extra_config": {
        "async/amqp": {
          "name": "krakend",
          "host": "amqp://guest:guest@rabbitmq:5672/",
          "exchange": "foo",
          "prefetch_count": 40,
          "auto_ack": true
        }
      }
    }
  ],
  "extra_config": {
    "documentation/postman": {
      "name": "KrakenD Enterprise API Gateway - Playground",
      "description": "Comprehensive demonstration environment showcasing KrakenD Enterprise capabilities including API composition, authentication, protocol conversion, rate limiting, and AI integration via MCP.",
      "version": "1.0.0",
      "folder": [
        {
          "name": "/API Composition",
          "description": "Endpoints demonstrating API aggregation, data transformation, masking, sequential processing, and mocked responses"
        },
        {
          "name": "/Authentication & Security",
          "description": "Various authentication methods (JWT, API Keys, Basic Auth) and security policy enforcement"
        },
        {
          "name": "/Routing & Wildcards",
          "description": "Wildcard endpoints, dynamic routing, geofencing, and HTTP method restrictions"
        },
        {
          "name": "/Protocol Conversion",
          "description": "Convert between protocols: REST to gRPC, GraphQL to REST, SOAP XML to REST JSON"
        },
        {
          "name": "/Performance & QoS",
          "description": "Rate limiting, caching strategies, and concurrent request handling for optimal performance"
        },
        {
          "name": "/Real-time Communication",
          "description": "WebSocket connectivity and real-time bidirectional communication"
        },
        {
          "name": "/AI Integration",
          "description": "Model Context Protocol (MCP) server for AI/LLM integration and intelligent data access"
        },
        {
          "name": "/Utilities",
          "description": "Static file serving and utility endpoints"
        }
      ]
    },
    "ai/mcp": {
      "servers": [
        {
          "name": "country-data-aggregator",
          "title": "Country Information Aggregator",
          "version": "1.0.0",
          "stateless": true,
          "instructions": "Provides unified country data by aggregating REST and GraphQL APIs. Use this to retrieve comprehensive information about countries including geography, demographics, and cultural data.",
          "tools": [
            {
              "name": "get_country_info",
              "title": "Get Country Information",
              "description": "Retrieves comprehensive country data by aggregating multiple public APIs (REST + GraphQL). Returns unified information including capital, population, area, languages, currency, flag, and bordering countries.",
              "type": "text",
              "input_schema": {
                "type": "object",
                "properties": {
                  "country_code": {
                    "type": "string",
                    "description": "Two-letter ISO 3166-1 alpha-2 country code (e.g., ES for Spain, FR for France, US for United States)",
                    "pattern": "^[A-Z]{2}$"
                  }
                },
                "required": [
                  "country_code"
                ]
              },
              "output_schema": {
                "type": "object",
                "properties": {
                  "country": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "native_name": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "capital": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "population": {
                    "type": [
                      "number",
                      "null"
                    ]
                  },
                  "area_km2": {
                    "type": [
                      "number",
                      "null"
                    ]
                  },
                  "currency": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "languages": {
                    "type": [
                      "array",
                      "null"
                    ],
                    "items": {
                      "type": "string"
                    }
                  },
                  "flag_emoji": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "borders": {
                    "type": [
                      "array",
                      "null"
                    ],
                    "items": {
                      "type": "string"
                    }
                  }
                }
              },
              "return_error_msg": true,
              "workflow": {
                "endpoint": "/__mcp/country-info/{country_code}",
                "backend": [
                  {
                    "@comment": "REST Countries API - provides geography, population, borders, flags",
                    "host": [
                      "https://restcountries.com"
                    ],
                    "url_pattern": "/v3.1/alpha/{country_code}",
                    "encoding": "safejson",
                    "is_collection": true,
                    "group": "rest_data",
                    "mapping": {
                      "collection": "countries"
                    }
                  },
                  {
                    "@comment": "GraphQL Countries API - provides currency, native name, emoji, languages",
                    "host": [
                      "https://countries.trevorblades.com"
                    ],
                    "url_pattern": "/",
                    "encoding": "json",
                    "target": "data.country",
                    "group": "graphql_data",
                    "extra_config": {
                      "backend/graphql": {
                        "type": "query",
                        "query": "query GetCountry($code: ID!) { country(code: $code) { name native capital currency emoji languages { code name } } }",
                        "variables": {
                          "code": "{country_code}"
                        }
                      }
                    }
                  }
                ],
                "extra_config": {
                  "modifier/jmespath": {
                    "@comment": "Simplified merge - take first element from REST array and combine with GraphQL",
                    "expr": "{country: rest_data.countries[0].name.common, native_name: graphql_data.native, capital: rest_data.countries[0].capital[0], population: rest_data.countries[0].population, area_km2: rest_data.countries[0].area, currency: graphql_data.currency, languages: graphql_data.languages[*].name, flag_emoji: graphql_data.emoji, borders: rest_data.countries[0].borders}"
                  }
                }
              }
            }
          ]
        }
      ]
    },
    "grpc": {
      "catalog": [
        "./grpc_catalog"
      ],
      "server": {
        "services": [
          {
            "name": "flight_finder.Flights",
            "methods": [
              {
                "name": "FindFlight",
                "input_headers": [
                  "x-my-custom-header"
                ],
                "payload_params": {
                  "page.cursor": "cursor"
                },
                "backend": [
                  {
                    "host": [
                      "http://localhost:8080"
                    ],
                    "url_pattern": "/__debug/{cursor}/"
                  },
                  {
                    "host": [
                      "grpc_flights:4242"
                    ],
                    "url_pattern": "/flight_finder.Flights/FindFlight",
                    "extra_config": {
                      "backend/grpc": {
                        "use_request_body": true
                      }
                    }
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    "router": {
      "return_error_msg": true,
      "disable_gzip": true
    },
    "auth/basic": {
      "@comment": "Location of the password file for endpoints requiring basic auth",
      "htpasswd_path": ".htpasswd"
    },
    "plugin/http-server": {
      "name": [
        "geoip",
        "url-rewrite"
      ],
      "geoip": {
        "citydb_path": "./geoip/GeoLite2-City.mmdb"
      },
      "url-rewrite": {
        "literal": {
          "/git-profile": "/git"
        },
        "regexp": [
          [
            "/git-profile/([a-z]{3})",
            "/git/${1}"
          ],
          [
            "/crypto-profile/([a-z]{3})",
            "/cryptos/${1}"
          ]
        ]
      }
    },
    "documentation/openapi": {
      "version": "1",
      "contact_name": "John Doe",
      "contact_email": "contact@example.com",
      "license_name": "MIT",
      "license_url": "https://opensource.org/licenses/MIT"
    },
    "auth/api-keys": {
      "keys": [
        {
          "key": "4d2c61e1-34c4-e96c-9456-15bd983c5019",
          "roles": [
            "role1",
            "role2"
          ],
          "@description": "ACME Inc."
        },
        {
          "key": "58427514-be32-0b52-b7c6-d01fada30497",
          "roles": [
            "admin",
            "user"
          ],
          "@description": "Administrators Inc."
        }
      ]
    },
    "telemetry/opentelemetry": {
      "service_name": "krakend_prometheus_service",
      "metric_reporting_period": 1,
      "trace_sample_rate": 1,
      "exporters": {
        "otlp": [
          {
            "disable_metrics": true,
            "disable_traces": false,
            "host": "jaeger",
            "name": "debug_jaeger",
            "port": 4317,
            "use_http": false
          }
        ],
        "prometheus": [
          {
            "name": "local_prometheus",
            "port": 9090,
            "process_metrics": true,
            "go_metrics": true
          }
        ]
      },
      "layers": {
        "global": {
          "disable_metrics": false,
          "disable_propagation": false,
          "disable_traces": false,
          "report_headers": true
        },
        "proxy": {
          "disable_metrics": false,
          "disable_traces": true,
          "report_headers": true
        },
        "backend": {
          "metrics": {
            "detailed_connection": true,
            "disable_stage": false,
            "read_payload": false,
            "round_trip": false
          },
          "traces": {
            "detailed_connection": false,
            "disable_stage": false,
            "read_payload": false,
            "report_headers": false,
            "round_trip": false
          }
        }
      }
    },
    "telemetry/logging": {
      "level": "DEBUG",
      "prefix": "[KRAKEND]",
      "syslog": false,
      "stdout": true
    },
    "telemetry/gelf": {
      "address": "logstash:12201",
      "enable_tcp": false
    },
    "security/cors": {
      "allow_origins": [
        "*"
      ],
      "allow_methods": [
        "POST",
        "GET"
      ],
      "allow_headers": [
        "Origin",
        "Authorization",
        "Content-Type"
      ],
      "expose_headers": [
        "Content-Length"
      ],
      "max_age": "12h"
    },
    "auth/revoker": {
      "@comment": "The values in this section must match the ones used in the revoker.json file",
      "hash_name": "optimal",
      "N": 10000000,
      "P": 1e-7,
      "port": 1234,
      "token_keys": [
        "jti",
        "sub"
      ],
      "TTL": 1500,
      "revoke_server_ping_url": "http://revoker:8081/instances",
      "revoke_server_ping_interval": "30s",
      "revoke_server_api_key": "639ee23f-f4c5-40c4-855c-912bf01fae87",
      "revoke_server_max_workers": 5
    }
  }
}