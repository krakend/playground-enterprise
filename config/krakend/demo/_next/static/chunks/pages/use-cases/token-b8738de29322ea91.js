(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7111],{5428:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/use-cases/token",function(){return t(8334)}])},8334:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return c}});var o=t(5893),s=t(1644),i=t(8563);let a=function(e){let{children:n}=e;return(0,o.jsx)(i.Z,{children:n})};function r(e){let n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{children:"Endpoint"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"/token\n"})}),"\n",(0,o.jsx)(n.p,{children:"This use case simulates when you have a monolithic service or similar, that is capable of generating a JSON payload (like a token) but is not able to cryptographically sign it. The signing component helps you to transition from a classic session workflow to a JWT workflow."}),"\n",(0,o.jsxs)(n.p,{children:["In this example we have a simulated token payload from a backend, that the ",(0,o.jsx)(n.code,{children:"auth/signer"})," component is going to take and sign cryptographically using an algorithm HS256. The resulting token can be used to access protected endpoints that require the same key, like the ",(0,o.jsxs)(n.a,{href:"/use-cases/private-custom",children:[(0,o.jsx)(n.code,{children:"/private/custom/"})," endpoint"]})]}),"\n",(0,o.jsxs)(n.p,{children:["Request a token here:\n",(0,o.jsx)(n.a,{href:"http://localhost:8080/token",children:"http://localhost:8080/token"})]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,o.jsx)(a,{...e,children:(0,o.jsx)(r,{...e})})}}},function(e){e.O(0,[9814,2681,182,6103,2888,9774,179],function(){return e(e.s=5428)}),_N_E=e.O()}]);